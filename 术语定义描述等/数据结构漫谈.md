## 本质上只有两种数据结构  数组与链表
## 其他数据结构都是由 数组 与 链表衍生出来的


## 链表是非连续存储 链表元素的访问的时间复杂度是O^n 链表元素的插入删除是O^1
## 链表 扩展 成树 形结构   树的递归 遍历 回溯  前端当中最重要的数据结构
## 链表 扩展 成图   vite webpack 有一定设计 内部文件的依赖图


## 数组 
## 数组是连续存储 因为是连续存储的所以数组元素可以随机访问  元素访问的时间复杂度时O^1 元素的增加 删除 是O^n
## 数组可以 扩展为 队列 栈
## 队列 先入先出   前端当中的应用 事件管理 任务队列


## 栈  先入后出   前端当中的应用  Jsx template 判断是否合法 作用域 作用域链  函数的执行栈
## example      
<!-- 
<div>
  <p>
    <span> </span>
  </p>
</div> 
-->
## 判断一段html 是否是正确对应且闭合的 从上到下 将开启标签推入栈中  当遇到闭合标签时  再依次出栈 判断出栈元素 与当前遍历元素是正确对应闭合



## 堆 树的变种



## 前端中 对象  hashTable
## 数据结构本质上是 数组 + 链表的组合  元素的访问跟数据量的大小无关 元素访问的时间复杂度时O ^ 1;
## example
## {a:1,b:2}
## a => 经过hash 算法 得到一个数字 该数字对应内存地址 就是存储元素值的数组元素的索引值  大数组 此处还有未解决之问题 hashMap ArrayMap 的扩容问题
## hashTable 的读取问题  获取到元素的 属性 或者索引值  经过hash算法 获取到内存索引地址(指针) 然后通过数据的随机访问 获取访问元素 所以访问很快时间复杂度为0^1
## hashTable 的hash碰撞问题
## 解决方式 1 扩容  2. 在相同地址下存储链表 访问到该地址时 再在链表当中进行一次遍历查找


ArrayMap 使用的是二分查找发 当数组长度每增加一倍 就会多判断一次

HashTable HashMap ArrayMap

HashMap和ArrayMap各自的优势

1.查找效率

HashMap因为其根据hashcode的值直接算出index，所以其查找效率是随着数组长度增大而增加的。

ArrayMap使用的是二分法查找，所以当数组长度每增加一倍时，就需要多进行一次判断，效率下降。

所以对于Map数量比较大的情况下，推荐使用


2.扩容数量

HashMap初始值16个长度，每次扩容的时候，直接申请双倍的数组空间。

ArrayMap每次扩容的时候，如果size长度大于8时申请size*1.5个长度，大于4小于8时申请8个，小于4时申请4个。

这样比较ArrayMap其实是申请了更少的内存空间，但是扩容的频率会更高。因此，如果当数据量比较大的时候，还是使用HashMap更合适，因为其扩容的次数要比ArrayMap少很多。

3.扩容效率

HashMap每次扩容的时候时重新计算每个数组成员的位置，然后放到新的位置。

ArrayMap则是直接使用System.arraycopy。

所以效率上肯定是ArrayMap更占优势。

这里需要说明一下，网上有一种传闻说因为ArrayMap使用System.arraycopy更省内存空间，这一点我真的没有看出来。arraycopy也是把老的数组的对象一个一个的赋给新的数组。当然效率上肯定arraycopy更高，因为是直接调用的c层的代码。

 

4.内存耗费

以ArrayMap采用了一种独特的方式，能够重复的利用因为数据扩容而遗留下来的数组空间，方便下一个ArrayMap的使用。而HashMap没有这种设计。

由于ArrayMap只缓存了长度是4和8的时候，所以如果频繁的使用到Map，而且数据量都比较小的时候，ArrayMap无疑是相当的节省内存的。

 

5.总结

综上所述，数据量比较小，并且需要频繁的使用Map存储数据的时候，推荐使用ArrayMap。

而数据量比较大的时候，则推荐使用HashMap。